# (라이브러리 이름)

## 자료구조

stack, queue, linked list, heap이 있습니다.

매크로 함수를 통해 제작했기 때문에, 기존 함수 형식과 살짝 다를 수 있습니다.

#### 사용 준비

DEFINE_STACK(T)로 선언하여 스택과 관련 함수를 사용할 수 있게 선언합니다.

먼저 T 자리에 스택에 저장할 데이터의 데이터타입을 넣습니다. 매우 길게 선언된 매크로 함수가 T 대신에 사용자가 저장할 데이터 타입을 넣게 됩니다.(텍스트 에디터에서 흔히 볼 수 있는 replace 기능을 떠올리십시오.)

#### STACK 관련 함수

STACK(T)는 해당 스택 구조체의 포인터 데이터타입(T##Stack *)입니다.

NEW_STACK(T) 는 자료형 T의 스택 공간을 제공하는 함수입니다.

int 데이터를 저장하는 새 스택 stack1을 만드려면 다음과 같이 사용합니다.

STACK(int) stack1 = NEW_STACK(int);

PUSH(T)는 T##Push의 대체된 표현입니다. T##Push는 T##Push(T##Stack * const st, T value)가 원형인 함수의 이름으로. 다음과 같이 사용합니다.

PUSH(T) ([스택 이름], [값]);, stack1의 경우 : PUSH(int) (stack1, 10);

POP(T)

DELETE_STACK(T)

IS_EMPTY_STACK(T)

IS_FULL_STACK(T)

#### QUEUE 

#### HEAP

#### LINKEDLIST

## 정렬

### 기본

#### 다양한 자료형을 받는 법

이 라이브러리에서 제공하는 정렬 함수의 요구사항 중 하나는 최대한 많은 데이터 타입을 받도록 하는 것입니다.

정렬 함수 중 몇 가지는 자료구조와 함께 제작되어, 위의 자료구조 관련 함수들처럼 사용할 수 있습니다.

자료구조와 함께 제작되지 않은 정렬 함수의 경우, void 포인터와 사용자가 직접 제작하는 comparator함수를 사용하며, 

여기서 comparator을 사용하는 이유는 정렬 함수의 사용자가 정렬할 데이터의 데이터 타입을 알고 있기 때문입니다. void포인터가 가지는 주소를 넘기게 되면 compartar 함수를 사용자가 알고 있는 자료형 중심으로 제작하여 역참조와 비교를 하게 됩니다. 자세한 내용은 아래의 비교 함수를 참고하십시오.

제한적인 상황에서 사용되어 대소 비교가 아닌 일치비교를 위주로 하는 정렬의 경우 해당 정렬 알고리즘에서 권장하는 데이터 타입을 사용하여 일일이 제작합니다.

#### stable, in-place

stable :

in-place :

#### swap

void swap(void * const fst, void * const snd, const unsigned sz) 

swap 함수는 두 대상의 주소(fst, snd)를 받아 그 크기만큼 교환하는 함수입니다.

다음과 같이 사용합니다.(swap([대상 1 주소], [대상 2 주소], [대상의 데이터 타입 크기]))

### SelectSortForArray

SelectSortForArray(void * seq, unsigned char type_size, const unsigned long long elem_size, int (*comparator)(const void * x, const void * y))

이 선택 정렬 함수는 배열의 시작 주소, 배열이 다루는 데이터 타입, 배열의 길이, 비교 함수를 받아서 선택정렬하는 함수입니다.

선택 정렬의 시간복잡도는 O(n^2)이며, ...

선택 정렬은 ... 때 가장 빠릅니다.

#### 비교 함수

사용자가 직접 비교함수를 작성해야 합니다. 조건은 다음과 같습니다.

1. 원형이 int [함수 이름] (const void * a, const void * b)
2. 앞의 대상이 뒤의 대상보다 크면 양수, 작으면 음수, 같으면 0을 리턴

void 포인터는 역참조가 불가능하기 때문에, 사용자가 데이터 타입을 알고 캐스팅을 해줍니다. 특히 구조체의 경우 비교할 멤버(= 정렬 기준)만 비교하도록 할 수 있습니다.

작성 예시는 다음과 같습니다.

(double 배열을 비교)

int doublecompare(const void* a, const void* b){

  if ( * (double * )a > * (double * )b)     return 1;

  else if ( * (double * )a > * (double * )b)  return -1;

  else                  return 0;

}

(person 구조체의 멤버 변수 age를 기준으로 비교)

int comparestruct(const void * x, const void * y){

​	int age = ((Person * )x)->age - ((Person * )y)->age;

​	return age > 0 ? 1 : (age == 0 ? 0 : -1);

}