# (라이브러리 이름)

## 자료구조

stack, queue, linked list, heap이 있습니다.

매크로 함수를 통해 제작했기 때문에, 기존 함수 형식과 살짝 다를 수 있습니다.

### 사용 준비

DEFINE_(자료구조 이름)(T)로 선언하여 헤딩 자료구조와 그 관련 함수를 사용할 수 있게 선언합니다.

먼저 T 자리에 자료구조에 저장할 데이터의 데이터타입을 넣습니다. 매우 길게 선언된 매크로 함수가 T 대신에 사용자가 저장할 데이터 타입을 넣게 됩니다.(텍스트 에디터에서 흔히 볼 수 있는 replace 기능을 떠올리십시오.)

매크로 함수처럼 사용하기 때문에 일반적인 함수 사용과 다를 수 있음에 주의하십시오.

#### STACK 관련 함수
사용 이전에 DEFINE_STACK(T)를 통해서 자료형 T를 사용하는 스택과 그 관련 함수를 사용할 수 있도록 하십시오. 세미콜론은 사용하지 않아도 됩니다.
'''DEFINE_STACK(int)'''

스택이 가지는 길이가 무한하지 않으며, unsigned long long의 최대치임에 주의하십시오.

STACK(T)는 해당 스택 구조체의 포인터 데이터타입(T##Stack *)입니다.

NEW_STACK(T) 는 자료형 T의 스택 공간을 제공하는 함수입니다.

int 데이터를 저장하는 새 스택 stack1을 만드려면 다음과 같이 사용합니다.
다른 함수의 대체 표현과 다르게 인자를 받지 않는다는 점에 주목하십시오.
'''STACK(int) stack1 = NEW_STACK(int);'''

PUSH(T)는 T##Push의 대체된 표현으로 스택이 차 있는지 검사한 뒤 그렇지 않다면 스택의 가장 위에 원소를 추가하는 함수입니다. T##Push는 void T##Push(T##_Stack * const st, T value)가 원형인 함수의 이름으로 다음과 같이 사용합니다.

'''PUSH(T) ([스택 이름], [값]); // stack1의 경우 : PUSH(int) (stack1, 10);'''

POP(T)는 T##Pop의 대체된 표현으로 스택이 비어있는지 검사한 뒤 그렇지 않다면 원소를 반환하는 함수입니다. T##Pop은 T T##Pop(T##_Stack * const st)가 원형인 함수의 이름으로 다음과 같이 사용합니다.

  POP(T) ([스택 이름]); // stack1의 경우 : POP(int) (stack1);

DELETE_STACK(T)은 T##DeleteStack의 대체된 표현입니다. 스택의 모든 노드를 메모리에서 해제한 뒤 스택 구조체를 마지막으로 해제하는 함수입니다. 
void T##DeleteStack(T##_Stack * const st)가 원형인 함수의 이름으로 다음과 같이 사용합니다.
'''
DELETE_STACK(T) ([스택 이름]);, stack1의 경우 : DELETE_STACK(int) (stack1);
'''
IS_EMPTY_STACK(T)는 T##IsEmptyStack의 대체된 표현으로 스택이 비어있는지 검사하는 함수입니다. T##IsEmptyStack은 unsigned T##IsEmptyStack(T##_Stack * const st)가 원형인 함수의 이름으로 다음과 같이 사용합니다.
'''
IS_EMPTY_STACK(T) ([스택 이름]);, stack1의 경우 : IS_EMPTY_STACK(int) (stack1);
'''

IS_FULL_STACK(T)는 T##IsFullStack의 대체된 표현으로 스택이 가득 차 있는지 검사하는 함수입니다. T##IsFullStack은 unsigned T##IsFullStack(T##_Stack * const st)가 원형인 함수의 이름으로 다음과 같이 사용합니다.
'''
IS_FULL_STACK(T) ([스택 이름]);, stack1의 경우 : IS_FULL_STACK(int) (stack1);
'''
#### QUEUE 
전체적인 사용 방법은 스택과 유사합니다.
큐가 가지는 길이가 무한하지 않으며, unsigned long long의 최대치임에 주의하십시오.

QUEUE(T)는 해당 큐 구조체의 포인터 데이터타입(T##Queue *)입니다.

NEW_QUEUE(T)는 자료형 T의 큐 공간을 제공합니다.
위와 함께 myqueue를 다음과 같이 선언하고 공간을 제공받을 수 있습니다.
다른 함수의 대체 표현과 다르게 인자를 받지 않는다는 점에 주목하십시오.
  QUEUE(int) myqueue = NEW_QUEUE(int)

ENQUEUE(T)는 T##Enqueue의 대체된 표현입니다. T##Enqueue(T##_Queue * const qu, T value) 을 원형으로 하는 함수의 이름이고, 큐에 값을 대입합니다.
myqueue에 10의 값을 대입하면 다음과 같습니다.
  ENQUEUE(int)(myqueue, 10);

DEQUEUE(T)는 T##Dequeue의 대체된 표현입니다. T T##Dequeue(T##_Queue * const qu)를 원형으로 하는 함수의 이름이고, 큐로부터 값을 뽑아냅니다. 방금 10값을 넣은 myqueue로부터 값을 뽑아내려면 다음과 같이 사용합니다.
  DEQUEUE(int)(myqueue);

DELETE_QUEUE(T)는T##DeleteQueue의 대체된 표현입니다. void T##DeleteQueue(T##_Queue * const qu)를 원형으로 하는 함수이고, 제공된 큐 공간과 구조체를 삭제하는 함수입니다. 다음과 같이 사용합니다.
  DELETE_QUEUE(int)(myqueue)

IS_EMPTY_QUEUE(T) IS_FULL_QUEUE(T)  
위 두 함수는 각각 T##IsEmptyQueue와 T##IsFullQueue를 대체하는 표현입니다. 원형은 각각 unsigned T##IsEmptyQueue(T##_Queue * const qu) 와 unsigned T##IsFullQueue(T##_Queue * const qu)이며 큐가 비었거나 꽉 차있는지의 여부를 반환합니다.
  IS_EMPTY_QUEUE(T);
  IS_FULL_QUEUE(T);

#### HEAP



#### LINKEDLIST

## 정렬

### 기본

#### 다양한 자료형을 받는 법

이 라이브러리에서 제공하는 정렬 함수의 요구사항 중 하나는 최대한 많은 데이터 타입을 받도록 하는 것입니다.

정렬 함수 중 몇 가지는 자료구조와 함께 제작되어, 위의 자료구조 관련 함수들처럼 사용할 수 있습니다.

자료구조와 함께 제작되지 않은 정렬 함수의 경우, void 포인터와 사용자가 직접 제작하는 comparator함수를 사용하며, 

여기서 comparator을 사용하는 이유는 정렬 함수의 사용자가 정렬할 데이터의 데이터 타입을 알고 있기 때문입니다. void포인터가 가지는 주소를 넘기게 되면 compartar 함수를 사용자가 알고 있는 자료형 중심으로 제작하여 역참조와 비교를 하게 됩니다. 자세한 내용은 아래의 비교 함수를 참고하십시오.

제한적인 상황에서 사용되어 대소 비교가 아닌 일치비교를 위주로 하는 정렬의 경우 해당 정렬 알고리즘에서 권장하는 데이터 타입을 사용하여 일일이 제작합니다.

#### stable, in-place

stable :

in-place :

#### predef.h - swap

predef.h에는 표준 라이브러리와 함께 간단한 swap함수, typedef를 통한 별칭을 포함하고 있습니다.

void swap(void * const fst, void * const snd, const unsigned sz) 

swap 함수는 두 대상의 주소(fst, snd)를 받아 그 크기만큼 교환하는 함수입니다.

다음과 같이 사용합니다.(swap([대상 1 주소], [대상 2 주소], [대상의 데이터 타입 크기]))

#### predef.h - byte

저희가 제작하는 정렬 함수의 핵심인 byte는 void 포인터에 대해 포인터 연산을 하기 위한 목적으로 사용하는 크기 1바이트의 자료형입니다.

byte가 unsigned char 이라기보다는 크기가 1바이트라는 사실이 중요한데, void 포인터를 byte * 로 형 변환을 한 뒤에

이동하고자 하는 크기 * 사용자가 제공한 자료의 바이트 크기(type_size) 단위로 포인터 연산을 하도록 합니다.

#### 비교 함수

사용자가 직접 비교함수를 작성해야 합니다. 조건은 다음과 같습니다.

1. 원형이 int [함수 이름] (const void * a, const void * b)
2. 앞의 대상이 뒤의 대상보다 크면 양수, 작으면 음수, 같으면 0을 리턴

void 포인터는 역참조가 불가능하기 때문에, 사용자가 데이터 타입을 알고 캐스팅을 해줍니다. 특히 구조체의 경우 비교할 멤버(= 정렬 기준)만 비교하도록 할 수 있습니다.

작성 예시는 다음과 같습니다.

(double 배열을 비교)

int doublecompare(const void* a, const void* b){

  if ( * (double * )a > * (double * )b)     return 1;

  else if ( * (double * )a > * (double * )b)  return -1;

  else                  return 0;

}

(person 구조체의 멤버 변수 age를 기준으로 비교)

int comparestruct(const void * x, const void * y){

​	int age = ((Person * )x)->age - ((Person * )y)->age;

​	return age > 0 ? 1 : (age == 0 ? 0 : -1);

}

(여러 문자열을 가질 때의 비교)



### 힘수

#### 비교가 있는 정렬 함수의 원형
대부분 함수의 원형은 
(void * seq, unsigned char type_size, const unsigned long long length, int (*comparator)(const void * x, const void * y))
입니다.

첫 번째 인자에는 정렬할 배열의 시작 주소가 들어갑니다. (리스트의 경우 따로 자료구조와 함께 제작됨.)

두 번째 인자에는 정렬할 배열 각 원소의 자료형의 크기가 들어갑니다. 구조체의 멤버를 비교하여 구조체 배열의 위치를 바꿀 경우에도 구조체 전체의 크기를 넣습니다.

세 번째 인자에는 정렬할 배열의 길이(즉, 배열 원소의 개수)가 들어갑니다.

네 번째 인자에는 비교함수가 들어갑니다. 위의 비교함수 작성을 참고해서 함수 이름을 넣어주시면 됩니다.

#### 동작 원리
void 포인터로 받은 seq 포인터를 byte*로 변환하여

#### SelectSort

SelectSort(void * seq, unsigned char type_size, const unsigned long long length, int (*comparator)(const void * x, const void * y))

이 선택 정렬 함수는 배열의 시작 주소, 배열이 다루는 데이터 타입, 배열의 길이, 비교 함수를 받아서 선택정렬하는 함수입니다.

선택 정렬의 시간복잡도는 O(n^2)이며, ...

선택 정렬은 ... 때 가장 빠릅니다.

#### CombSort

CombSort(void* seq, const unsigned long long type_size, const unsigned long long length, int (*comparator)(const void* x, const void* y))

빗 정렬 함수는 배열의 시작 주소, 배열이 다루는 데이터 타입, 배열의 길이, 비교 함수를 매개변수로 받아 특정 감소량에 따라 간격을 줄여가며 버블 정렬을 수행하는 함수입니다.

빗 정렬의 시간 복잡도는 최선의 경우 O(n log n), 평균적인 경우 O(n^2/(gap이 줄어든 횟수)^2), 최악의 경우 O(n^2)이고 공간 복잡도는 O(1)입니다.

#### InsertionSortArray

InsertionSortArray(void* seq, const unsigned long long type_size, const unsigned long long length, int (*comparator)(const void* x, const void* y))

삽입 정렬 함수는 배열의 시작 주소, 배열이 다루는 데이터 타입, 배열의 길이, 비교 함수를 매개변수로 받아 배열의 두 번째 원소부터 시작해 앞의 원소들과 비교하여 삽입할 위치를 찾은 후 그 위치의 원소를 뒤로 옮긴 후 삽입하는 함수입니다.

삽입 정렬의 시간 복잡도는 최선의 경우 O(n), 평균적 혹은 최악의 경우 O(n^2)이고 공간 복잡도는 O(1)입니다.

#### ShellSort

ShellSort(void* seq, const unsigned long long type_size, const unsigned long long length, int (*comparator)(const void* x, const void* y))

셸 정렬 함수는 배열의 시작 주소, 배열이 다루는 데이터 타입, 배열의 길이, 비교 함수를 매개변수로 받아 간격을 (배열의 원소 개수/2) 부터 1이 될 때까지 반으로 줄여가며 같은 간격에 있는 원소들을 삽입 정렬을 수행하는 함수입니다.

셸 정렬의 시간 복잡도는 최선의 경우 O(n), 평균적인 경우 O(n^1.5),  최악의 경우 O(n^2)이고 공간 복잡도는 O(1)입니다.

